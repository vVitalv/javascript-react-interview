## Вопросы на собеседовании JS React разработчика

Список вопросов постоянно актуализируется. Прошу принимать участие!

#### JavaScript

<details><summary>Какие типы данных есть в JS</summary>

**Примитивы** (примитивный тип данных) - это данные, которые не являются объектом и не имеют методов. Все примитивы неизменяемы (*immutable*).

В JS есть 7 примитивных типов данных:

1. **number** - используется как для целых, так и для дробных чисел.
Существуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (not a number), также принадлежащие типу `number`.
2. **bigint** - содержит числа больше, чем 2<sup>53</sup> (или меньше, чем -2<sup>53</sup>), которые не может содержать тип `number`.
Чтобы создать значение типа `bigint`, необходимо добавить `n` в конец числового литерала.
3. **string** - строка.
4. **boolean** - логический тип данных, который может содержать одно из двух значений `true` или `false`.
5. **null** - тип данных, состоящий из единственного значения `null`, которое имеет смысл "*ничего*". 
Результат `typeof null == "object"` – это официально признанная ошибка в языке, которая сохраняется для совместимости.
6. **undefined** - тип данных, состоящий из одного единственного значения `undefined`, которое имеет смысл "*значение не присвоено*".
7. **symbol** - представляет собой уникальный идентификатор.

За исключением `null` и `undefined`, все примитивные значения имеют объектный аналог, который оборачивает значение примитивного типа: `String`, `Number`, `Boolean`, `Symbol`, которые, в свою очередь, имеют соответствующие методы. 

[Подробнее](https://developer.mozilla.org/ru/docs/Glossary/Primitive)

8. **object** - используется для коллекций данных и для объявления более сложных сущностей (функции, массивы и т.д.).

`object` относится к ссылочному (*reference*) типу данных и содержит ссылку на ячейку в памяти, где непосредственно записаны данные. Эти данные, в отличие от примитивов, изменяемы (*mutable*).

[Подробнее](https://learn.javascript.ru/object)

</details>

<details><summary>Различия между let, const и var</summary>

Область видимости переменных, объявленных при помощи `var` может быть как *локальной*, так и *глобальной* и зависит от места их объявления. 
Если переменная объявлена ***вне*** блока функции, тогда область ее видимости будет *глобальной*, то есть переменная будет доступна в `window`.
Область видимости переменной, объявленной ***внутри*** функции будет *локальной* и переменная будет доступна только в блоке функции.

Область видимости переменных, объявленных при помощи `let` и `const` - блочная.

***

Переменные, объявленные при помощи `var`, могут как объявляться заново, так и обновляться.

Переменные, объявленные при помощи `let`, могут обновляться, но не объявляться повторно.

Переменные, объявленные при помощи `const`, нельзя обновить или объявить заново.

***

Переменные всех видов поднимаются в верх своей области видимости (*hoisting*). Но переменные, объявленные при помощи `var`, инициализируются как `undefined`, а объявленные с использованием `let` или `const` — не инициализируются.

***

При помощи `var` или `let` можно объявлять переменные без их инициализации, но при объявлении через `const`, переменная должна инициализироваться.

</details>

<details><summary>Способы объявления функций</summary>

1. **Function Declaration** (*объявление функции*) - "классическое" объявление функции. Объявляется отдельной конструкцией в основном потоке кода посредством служебного слова `function`. 
```javascript
function sum(a, b) {
  return a + b;
}
```
2. **Function Expression** (*функциональное выражение*) - функция, созданная внутри другого выражения или синтаксической конструкции. Такая функция может быть *анонимной*.
```javascript
let sum = function(a, b) {
  return a + b;
}
```

3. **Arrow Function** (*стрелочная функция*) - имеет более короткий синтаксис и особую лексику `this`. Стрелочные функции *анонимны*.
```javascript
let func = (args) => expression
```

Важное отличие *Function Declaration* от *Function Expression* в том, ***когда*** создается функция движком JS.
- *Function Declaration* обрабатываются перед выполнением блока кода. Они видны во всём блоке.
- *Function Expression* создаются только когда поток выполнения достигает их.

[Подробнее](https://learn.javascript.ru/function-expressions#function-expression-v-sravnenii-s-function-declaration)

</details> 

<details><summary>Особенности стрелочных функций</summary>

`Стрелочные функции`:
- не содержат собственный контекст `this`, а используют значение `this` окружающего контекста.
- не имеют собственного объекта `arguments`, поэтому в теле стрелочных функций `arguments` будет ссылаться на переменную в окружающей области.
- не могут быть вызваны с `new`.

[Подробнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

</details> 

#### React

<details><summary>Что такое Порталы</summary>

**Порталы** позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента. Типовой случай применения порталов — когда в родительском компоненте заданы стили `overflow: hidden` или `z-index`, но нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
Создание портала:
```javascript
ReactDOM.createPortal(child, container)
```

[Подробнее](https://ru.reactjs.org/docs/portals.html)

</details>

#### CSS

<details>
<summary></summary>

</details>
