## Вопросы на собеседовании JS React разработчика

Список вопросов постоянно актуализируется. Прошу принимать участие!

#### JavaScript

<details><summary>Что такое ООП</summary>

Ключевым принципом ООП выступает разделение задач и ответственностей по сущностям.
Сущности создаются в коде как объекты. При этом каждая из них объединяет некую информацию (свойства) и действия (методы), которые может выполнять.

Ключевые принципы ООП:
1. **Наследование** – это возможность создавать классы на основе других классов. С помощью этого принципа можно определять родительский класс (с нужными свойствами и методами), а затем дочерний класс, который будет наследовать от родителя все свойства и методы.
2. **Инкапсуляция** — это размещение в одном компоненте данных и методов, которые с ними работают. Обеспечивает механизм сокрытия, позволяющий разграничивать доступ к различным компонентам программы.
3. **Абстракция** — это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе.
4. **Полиморфизм** означает «множество форм» и отражает способность метода возвращать разные значения, согласно определённым условиям.

</details>

<details><summary>Какие типы данных есть в JS</summary>

**Примитивы** (примитивный тип данных) - это данные, которые не являются объектом и не имеют методов. Все примитивы неизменяемы (*immutable*).

В JS есть 7 примитивных типов данных:

1. **number** - используется как для целых, так и для дробных чисел.
Существуют специальные числовые значения `Infinity` (бесконечность) и `NaN` (not a number), также принадлежащие типу `number`.
2. **bigint** - содержит числа больше, чем 2<sup>53</sup> (или меньше, чем -2<sup>53</sup>), которые не может содержать тип `number`.
Чтобы создать значение типа `bigint`, необходимо добавить `n` в конец числового литерала.
3. **string** - строка.
4. **boolean** - логический тип данных, который может содержать одно из двух значений `true` или `false`.
5. **null** - тип данных, состоящий из единственного значения `null`, которое имеет смысл "*ничего*". 
Результат `typeof null == "object"` – это официально признанная ошибка в языке, которая сохраняется для совместимости.
6. **undefined** - тип данных, состоящий из одного единственного значения `undefined`, которое имеет смысл "*значение не присвоено*".
7. **symbol** - представляет собой уникальный идентификатор.

За исключением `null` и `undefined`, все примитивные значения имеют объектный аналог, который оборачивает значение примитивного типа: `String`, `Number`, `Boolean`, `Symbol`, которые, в свою очередь, имеют соответствующие методы. 

[Подробнее](https://developer.mozilla.org/ru/docs/Glossary/Primitive)

8. **object** - используется для коллекций данных и для объявления более сложных сущностей (функции, массивы и т.д.).

`object` относится к ссылочному (*reference*) типу данных и содержит ссылку на ячейку в памяти, где непосредственно записаны данные. Эти данные, в отличие от примитивов, изменяемы (*mutable*).

[Подробнее](https://learn.javascript.ru/object)

</details>

<details><summary>Различия между let, const и var</summary>

Область видимости переменных, объявленных при помощи `var` может быть как *локальной*, так и *глобальной* и зависит от места их объявления. 
Если переменная объявлена ***вне*** блока функции, тогда область ее видимости будет *глобальной*, то есть переменная будет доступна в `window`.
Область видимости переменной, объявленной ***внутри*** функции будет *локальной* и переменная будет доступна только в блоке функции.

Область видимости переменных, объявленных при помощи `let` и `const` - блочная.

***

Переменные, объявленные при помощи `var`, могут как объявляться заново, так и обновляться.

Переменные, объявленные при помощи `let`, могут обновляться, но не объявляться повторно.

Переменные, объявленные при помощи `const`, нельзя обновить или объявить заново.

***

Переменные всех видов поднимаются в верх своей области видимости (*hoisting*). Но переменные, объявленные при помощи `var`, инициализируются как `undefined`, а объявленные с использованием `let` или `const` — не инициализируются.

***

При помощи `var` или `let` можно объявлять переменные без их инициализации, но при объявлении через `const`, переменная должна инициализироваться.

</details>

<details><summary>Способы объявления функций</summary>

1. **Function Declaration** (*объявление функции*) - "классическое" объявление функции. Объявляется отдельной конструкцией в основном потоке кода посредством служебного слова `function`. 
```javascript
function sum(a, b) {
  return a + b;
}
```
2. **Function Expression** (*функциональное выражение*) - функция, созданная внутри другого выражения или синтаксической конструкции. Такая функция может быть *анонимной*.
```javascript
let sum = function(a, b) {
  return a + b;
}
```

3. **Arrow Function** (*стрелочная функция*) - имеет более короткий синтаксис и особую лексику `this`. Стрелочные функции *анонимны*.
```javascript
let func = (args) => expression
```

Важное отличие *Function Declaration* от *Function Expression* в том, ***когда*** создается функция движком JS.
- *Function Declaration* обрабатываются перед выполнением блока кода. Они видны во всём блоке.
- *Function Expression* создаются только когда поток выполнения достигает их.

[Подробнее](https://learn.javascript.ru/function-expressions#function-expression-v-sravnenii-s-function-declaration)

</details> 

<details><summary>Особенности стрелочных функций</summary>

`Стрелочные функции`:
- не содержат собственный контекст `this`, а используют значение `this` окружающего контекста.
- не имеют собственного объекта `arguments`, поэтому в теле стрелочных функций `arguments` будет ссылаться на переменную в окружающей области.
- не могут быть вызваны с `new`.

[Подробнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

</details> 

#### React

<details><summary>Какие есть методы жизненного цикла компонента в React</summary>

</details>

<details><summary>Какие хуки есть в React</summary>

</details>

<details><summary>Как работает хук useState</summary>

</details>

<details><summary>Как работает хук useEffect</summary>

</details>

<details><summary>Что такое мемоизация</summary>

</details>

<details><summary>Что такое HOC</summary>

</details>

<details><summary>Что такое Порталы</summary>

**Порталы** позволяют рендерить дочерние элементы в DOM-узел, который находится ***вне*** DOM-иерархии родительского компонента. Типовой случай применения порталов — когда в родительском компоненте заданы стили `overflow: hidden` или `z-index`, но нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.

Создание портала:
```javascript
ReactDOM.createPortal(child, container)
```

[Подробнее](https://ru.reactjs.org/docs/portals.html)

</details>

#### HTML и CSS

<details><summary>Как выровнять элемент по центру</summary>

1. Выравнивание по горизонтали:
- для инлайн элементов поставить родителю свойство `text-align: center`
- для блочных элементов применить элементу `margin: auto` (у элемента должна быть указана ширина)
- если размер центрируемого элемента известен, а родителя – нет, присвоисть родителю `position:relative`, потомку `position:absolute; left:50%` и сместить влево на половину ширины потомка `margin-left:-<половина-ширины-потомка>`
- создать `flex` контейнер с `justify-content:center` (или `align-items:center` для `flex-direction:column`)
2. Выравнивание по вертикали:
- сделать элемент-родитель ячейкой таблицы при помощи `display:table-cell` или реальной таблицы, и поставить ему `vertical-align:middle`
- если размер центрируемого элемента известен, а родителя – нет, присвоить родителю `position:relative`, потомку `position:absolute; top:50%` и приподнять на половину высоты потомка `margin-top:-<половина-высоты-потомка>`
- если нужно отцентрировать одну строку в блоке, высота которого известна, поставить блоку `line-height: <высота>`
- если высота родителя известна, а центрируемого элемента – нет, поставить `line-height` родителю во всю его высоту, а потомку поставить `display:inline-block`
- создать `flex` контейнер с `align-items:center` (или `justify-content:center` для `flex-direction:row`)

[Подробнее](https://learn.javascript.ru/css-center)

</details>
